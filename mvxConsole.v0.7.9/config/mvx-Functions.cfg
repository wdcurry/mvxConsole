# File          mvx-Functions.cfg
# Desc          Functions specific to mvx app
# Author        Drew Curry, ApeStaking
# Version       0.7.9
# Date          dec30-2022
# Location      MultiversX's config folder

#!/bin/bash
set -e


# ------------------------------------------
# Function      ShowMvxMenu
# Desc          Performs all the tasks to present a concise menu  
#               to manage and get a valid MultiservX menu option
#               ** changed to use newer slick read
# ------------------------------------------
function ShowMvxMenu {

        #======DRAW MENU======
        # setup screen and show menu
        # note the $empty on lines where text is set in header, needed to
        #       round out the due layouts. Can be addressed by augmenting
        #       the calc for attrib (subsequent edits obviated this need)
        clear
        # echo -e "$BWHITE${$title}"

        tabs $((titleTab)),$((farRightTab))

        echo -e "$GOLDHEADERCOLOR${blankLine}"
        # having a love/hate thing with the terminal app and keeping the header consise
        #	sometimes it needs the $empty variable to fill in the last tab spot, 
        #	other times not, i have not cleared this issue as yet.
        #echo -e "\t$GOLDHEADERCOLOR${title}\t$empty"
        echo -e "$GOLDHEADERCOLOR${blankLine}"
	# minor graphic hack until i master tab control, as the terminal messes with the fill in
	#	so we will create the full colored line, then return to print text.
	tput cuu 1        
        echo -e "\t$GOLDHEADERCOLOR${title}\t"        
        echo -e "$GOLDHEADERCOLOR${blankLine}"

        # create tabs for neatness
        tabs $menuTab0,$menuTab1,$menuTab2,$farRightTab

        #echo -e "$GOLDHEADERCOLOR Option \tDescription \tSpecial Notes\t$empty"
        echo -e "$GOLDHEADERCOLOR${blankLine}"
        tput cuu 1
        echo -e "$GOLDHEADERCOLOR Option \tDescription \tSpecial Notes\t\t"
        echo -e "$GOLDHEADERCOLOR${blankLine}$NOBACKCOLOR"
        echo -e "$printableLine"

        for i in $(seq 1 $optionCount)
        do
                zbi=$(( $i - 1 ))
                # if no note exists, don't print the index empty
                rawNote=${optionsDescsNotes[$zbi]}
		# without the quotes, this next IF is challenged, test when time permits, as to why.
                if [ "$rawNote" == "$empty" ]; then
                        noteText=" "
                else
                        noteText="$mvxYELLOW${indexesToOptions[$zbi]}: $mvxGREEN$rawNote"
                fi

		#create alternating row feel for even-numbered rows
		if [ $((i%2)) -eq 0 ]; then

			# take the time to do this correctly, as current line formats are blocking out pre-formatting
			
			# create a dim separator line then move back up one row
			# not the look i wanted: echo -e "\e[2;4m$blankLine\e[0m"
			#echo -e "$GOLDHEADERCOLOR${blankLine}"

			#tput cuu 1
			aaa=1 # placemat to avoid shell order, if we comment out section inside if block
		fi

                echo -e  "$mvxYELLOW ${indexesToOptions[$zbi]}: ${options[$zbi]}\t$mvxGREEN${optionsDescs[$zbi]}\t$mvxGREEN${noteText}"
                #echo -e  "$YELLOW ${options[$zbi]}\t$GREEN${optionsDescs[$zbi]}${noteText}"

        done

        # setup a slightly fancy attib line
        tabs $((attribTab))
        echo -e $BWHITE$printableLine
        echo -e "\t$DIMCOLOR${attrib}$STOPCOLORSCHEME$BWHITE$BOLDCOLOR"

        tabs 1,20,75,${appWidth}

        #reset IFS
        IFS="$OFS"

        # adjust cursor location for a neater presentation of the read prompt
        # this places the cursor on the same line as the attrib slug
        tput cuu 1

        #======END DRAW MENU======

        # setup call to secure user option for how to run commands, receiving a zero-based integer for options array
        # todo: can i seq this rather than manually creating ?
        unset choice
        getValidChoice ">Select mvx option (QqXx-quit)" choice "${acceptedKeys[@]}"
	zbIndex=${optionsIndexes[$choice]}

        eval "$1=${zbIndex}"

}
# End of Function      ShowMvxMenu
# ------------------------------------------

# ------------------------------------------
# Function	RegularNodeUpgrade
# Desc		Will perform all steps in *normal* upgrade,
#		and will ask (a-auto, s-stepXstep, c-cancel)
#
# ------------------------------------------
function RegularNodeUpgrade {
	#Create an array of commands to run in a loop, allowing for minimal coding for separate runModes (auto/stepXstep)
	# Remember to not pass aliases, as they do not get interpreted correctly
	commandsToRun=( 
                'cd ~/elrond-go-scripts'
                './script.sh github_pull'
                './script.sh upgrade'
                './script.sh start'
                '$HOME/elrond-utils/termui -address localhost:8080'
		)

        zbNumSteps=$(( ${#commandsToRun[@]} - 1 ))

        # setup call to secure user option for how to run commands
        choices=( A a S s C c )
        unset runMode
        getValidChoice "Run upgrade (Aa-auto, Ss-stepXstep, or Cc-cancel)" runMode "${choices[@]}"

        case $runMode in
                "A")    echo "Running regular upgrade"
			yesOrCancel okToCont 'Ok to upgrade?'
			if [[ $okToCont	 == "Y" ]]; then
				for i in $(seq 0 $zbNumSteps); do
	                                eval "${commandsToRun[$i]}"
	                                echo
	                        done
			fi;;

                "S")    echo "running stepXstep regular upgrade"
                        for i in $(seq 0 $zbNumSteps); do
			        # setup call to secure user option for how to run commands
			        execChoices=( Y y S s C c )
			        unset execNextChoice
			        getValidChoice "Run next command (${commandsToRun[$i]})? (Yy-yes, Ss-skip, or Cc-cancel)" execNextChoice "${execChoices[@]}"
			        case $execNextChoice in
			                "Y")	eval "${commandsToRun[$i]}" ;;
	                                "S")	;;
	                                "C")	tapToContinue "Regular Upgrade cancelled."
	                                	break ;;
	                                *)	;;
                                esac
                        done ;;
                "C")	tapToContinue "Regular Upgrade cancelled.";;
                *)      ;;
        esac

}

# ------------------------------------------
# Function      FullNodeUpgrade
# Desc          Will perform all steps in *normal* upgrade,  
#               and will ask (a-auto, s-stepXstep, c-cancel)
#
# ------------------------------------------
function FullNodeUpgrade {
        #Create an array of commands to run in a loop, allowing for minimal coding for separate runModes (auto/stepXstep)
        # Remember to not pass aliases, as they do not get interpreted correctly
        # NOTE: THIS IS DESTRUCTIVE and will be double-checked for ok to continue.
	# todo: this routine needs a proper exiting message, due to multiple exit points
        commandsToRun=(
                'cd ~/elrond-go-scripts'
                './script.sh github_pull'
                './script.sh stop'
                './script.sh remove_db'
                './script.sh upgrade'
                './script.sh start'
                '$HOME/elrond-utils/termui -address localhost:8080'
                )

        zbNumSteps=$(( ${#commandsToRun[@]} - 1 ))

        # setup call to secure user option for how to run commands
        choices=( A a S s C c )
        unset runMode
        getValidChoice "Run FULL upgrade (Aa-auto, Ss-stepXstep, or Cc-cancel)" runMode "${choices[@]}"

        case $runMode in
                "A")    echo "Running full upgrade"
                        yesOrCancel okToCont 'A FULL upgrade will wipe the current database, are you sure?'
                        if [[ $okToCont  == "Y" ]]; then
                                for i in $(seq 0 $zbNumSteps); do
                                	#tmp: testing loops
#                                       echo "in AUTO MODE:${commandsToRun[$i]}"
					eval "${commandsToRun[$i]}"
                                         
                                        echo
                                done
                        fi;;

                "S")    echo "running stepXstep full upgrade"

                	# one last warning before continuing
                        yesOrCancel okToCont 'A FULL upgrade will wipe the current database, are you sure?'
                        if [[ $okToCont  == "Y" ]]; then

	                        for i in $(seq 0 $zbNumSteps); do
	                                # setup call to secure user option for how to run commands
	                                execChoices=( Y y S s C c )
	                                unset execNextChoice
	                                getValidChoice "Run next command (${commandsToRun[$i]})? (Yy-yes, Ss-skip, or Cc-cancel)" execNextChoice "${execChoices[@]}"

	                                case $execNextChoice in
#                                                "Y")    echo "in AUTO MODE:${commandsToRun[$i]}";;
                                                "Y")    eval "${commandsToRun[$i]}" ;;	                                
	                                        "S")    ;;
	                                        "C")    tapToContinue "Full Upgrade cancelled."
	                                        	break ;;
	                                        *)      ;;
	                                esac
	                        done
                        fi;;
                "C")    tapToContinue "Regular Upgrade cancelled.";;
                *)      ;;
        esac

}

# ------------------------------------------
# Function      ToggleDEBUG
# Desc          Simplifies the task of flipping between DEBUG and INFO modes
#		WIP - Juat copied from RegularNodeUpgrade() to prep
#			requires the node selection code from runTermui
#			and btw, this automation of commands might not be as revelant here as no stepXstep is to be offered.
# ------------------------------------------
function ToggleDEBUG {

echo "DEBUG/INFO Toggle coming ssoon!"

}












# ======Utility Functions======

#================ 
# accept array and offer a looping read until user enters a valid choice, unless they ctrl-c out of sequence.
# To call this correctly, the unset result var must be the first param and the array the next array
# like:
#	choices=( A S C )
#       unset result
#       getValidChoice "run upgrade (A-auto, S-stepXstep, or C-cancel)" result "${choices[@]}"
#       echo -e "returned value was ${result}"
# A bit of fun: one char entry only, prompt lines grows with an error indicator if wrong entry tried, and
#	we stay on the same line rather than the cumbersome manner most such entry efforts use.
# Todo: # return the zero-based choice of the option selected, but this is challenging to do simply.
function getValidChoice {

	if (( $# == 0 )); then
		echo "usage: getValidChoice {arrayOfChoices}"
	fi

	validChoices=("$@")
	unset choice
	prompt=$1
	
	# manage variables to allow a growing prompt in response to wrong inputs
	origPrompt=$prompt
	errorPromptPrefix=""
	errorPromptSymbol="â“§ " 
	alreadyShown=0

	# turn off ENTER key, save location of cursor, allowing calling app to be independent of this routine
	stty igncr ; tput sc
	while [[ ! ${validChoices[*]} =~ (^|[[:space:]])"$choice"($|[[:space:]]) ]]; do
		if [[ alreadyShown -eq 1 ]]; then
			# grow cursor one error icon per bad entry, then reset cursor location
			errorPromptPrefix+="$errorPromptSymbol"
			prompt="$errorPromptPrefix$origPrompt"
			tput rc
		fi
		# read only one char, then stay on same line
		# here, without -e, the four cursor arrow keys are interpreted as A-D
                read -N 1 -r -ep "${prompt}: " choice

		#todo: orig code left the caller code with cursor ON the original spot of selection, allowing for clean over-write,
		#	this is not currently working as such, test why.

		alreadyShown=1
	done

	# turn ENTER key back on
	stty -igncr
	# set calling variable that informs external routine of selected value
	# upp-case the choice
	choice=${choice^^}
	eval "$2=${choice}"
	# set cursor to next line to be polite
	#echo
}

#================ 
# wrap call to getValidChoice to enable simple yesToContinue function
function yesOrCancel {
	# important Bash detail: wrapping variable in quote tells Bash to ignore spaces in string, lest they be array-like structures
	#	thus we use "$2" to grab full pass sentence of prompt
	
	ycPrompt="Continue? (Yy-yes,Cc-cancel)"

        if [[ $# -gt 1 ]]; then
        	#caller passes custom prompt, use it
                ycPrompt="$2"" (Yy-yes,Cc-cancel)"
        fi
	
	ycChoices=( Y y C c )
	unset ycChoice
        getValidChoice "$ycPrompt" ycChoice "${ycChoices[@]}"
	# return choice to caller's first passed variable, upper-cased by getValidChoice()
	eval "$1=${ycChoice}"

	# and for a shortcut in caller code, return 1 for yes, 0 for no
	# purpose not needed it seemed, lfr
#	if [[ $ycChoice == "Y" ]]; then
#		echo "exiting true"
#		echo 0
#	else
#		echo "exiting false"
#		echo 1
#	fi

}

#================
# simple function to give user control before cycling back to calling script
# if a param is passed, it is prepended to the prompt
function tapToContinue {

	if [[ ! -z $1 ]]; then
		tapPrompt="$1"", press any key to continue..."
	else
                tapPrompt="Press any key to continue..."
	fi
	echo -e
	read -n 1 -p "$tapPrompt"

}


#================ 
# encapsulate call to get #nodes MultiversX installed,
# returns: param1: #nodes, param2*: zero-based #nodes, param3*: usable seq array, param4*: ??
# todo: create an if here and if no .numberofnodes is found, count node-X folders
function getMultiversXNodeInfo {
	# todo: noted if this var is set local, then the return'd value is null'd out upon return to caller, seems as-ref not as-val, confirm
	numNodesLocal=0
	# replace this with mvx-oriented setting for homebase
	if [[ -f $CUSTOM_HOME/.numberofnodes ]]; then  numNodesLocal=$(cat $CUSTOM_HOME/.numberofnodes); fi
	
	# create value-added info and pass if asked for
	zbNumNodes=$(( numNodesLocal - 1 ))
	nodeArray="( "$(seq -s " " 0 $zbNumNodes)" )"

	# return if required
        numParams=$#
	eval "$1=${numNodesLocal}"	
        if [[ $numParams -gt 1 ]]; then eval "$2=${zbNumNodes}"; fi
	# seriously, the formatting required for bash is astoundingly random it seems
        if [[ $numParams -gt 2 ]]; then eval "$3="'$nodeArray'""; fi
	
}

