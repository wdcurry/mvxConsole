# File		ApeConsole-MenuVariables.cfg
# Variables required by ApeConsole.sh
# Author	Drew Curry, ApeStaking
# Version	0.7.9
# Date		dec30-2022
# Location	MultiversX's config folder

#!/bin/bash

# create loop limits for A(ascii 65) to 0-based value of the # of options
# and setup first loop iteration to run
# NOTE: the linear ascii sequence for menu control was essentially obsoleted for acceptedKey[], allowing us to keep 'Q' to quit ;)
optionCount=17
loopLowerLimit=65
loopUpperLimit=$(($loopLowerLimit+$optionCount-1))

#tabs for menu, could set in array but not much is gained by that
menuTab0=1
menuTab1=22
menuTab2=76

#obsoleted
promptText="What is your desired action? "

# the main options, each selectable by one char
optA="Install"
optB="ObservingSquad"
optC="Upgrade"
optD="UpgradeSquad"
optE="UpgradeProxy"
optF="RemoveDB"
optG="StartNode"
optH="StopNode"
optI="CleanupNode"
optJ="GithubPull"
optK="AddNode"
optL="GetLogs"
optM="Benchmark"
optN="Termui"
optO="NodeUpgrade"
optP="FullNodeUpgrade"
optR="ToggleDEBUG"
# hidden options below
optQ="Quit"
optX="Exit"


# the short desc for each option
optADesc="Install a MultiversX node"
optBDesc="Setup a MultiversX mainnet Observing Squad"
optCDesc="Upgrade existing nodes"
optDDesc="Upgrade existing mainnet Observing Squad observers"
optEDesc="Upgrade the installed proxy"
optFDesc="Remove the nodes databases"
optGDesc="Start all the installed nodes"
optHDesc="Stop all the installed nodes"
optIDesc="Remove everything from the host"
optJDesc="Get latest version of scripts from github"
optKDesc="Add more nodes to your current running ones"
optLDesc="Get the logs from all the nodes"
optMDesc="Run the performance assessment tool"
optNDesc="Run the MultiversX Termui app"
optODesc="Complete Regular Node Upgrade"
optPDesc="Complete FULL Node Upgrade (Testnet)"
optRDesc="Toggle a node between DEBUG and INFO"
# hidden options below
optQDesc="Quit the mvx console app"
optXDesc="eXit the mvx console app"


# an optional note per option, noting the use of color if required
# the menu will skip the note if empty, and include the letter to aid visual acuity

# one nicety for newbies: remind them to get a githubtoken if not present
if [[ ${#GITHUBTOKEN} -eq 0 ]]; then
	githubDescNote="${BRED}Please setup your githhub token"
else
        githubDescNote="Token: ${GITHUBTOKEN}"
fi

optADescNote=$empty
optBDescNote=$empty
optCDescNote=$empty
optDDescNote=$empty
optEDescNote=$empty
optFDescNote="Individual node selection"
optGDescNote="Will also start MultiversX-proxy if installed"
optHDescNote="Will also stop MultiversX-proxy if installed"
optIDescNote=$empty
optJDescNote=$githubDescNote
optKDescNote="${BRED}Not compatible with the observing_squad install"
optLDescNote=$empty
optMDescNote=$empty
optNDescNote="Select from any installed node"
optODescNote="Performs all steps in a standard upgrade"
optPDescNote="${BRED}Performs the FULL upgrade with DB WIPE"
optRDescNote="${BRED}This will restart your node"
# hidden option notes if required


# we include the 'hidden options" at the END of the arrays, as the menu ONLY displays the first optionCount entries, but the acceptedKeys INCLUDES the 
#	hidden options and thus the processing Case statement will find and act on them, and they need no DescNote for now
options=($optA $optB $optC $optD $optE $optF $optG $optH $optI $optJ $optK $optL $optM $optN $optO $optP $optR $optQ $optX )
optionsDescs=($optADesc $optBDesc $optCDesc $optDDesc $optEDesc $optFDesc $optGDesc $optHDesc $optIDesc $optJDesc $optKDesc $optLDesc $optMDesc $optNDesc $optODesc $optPDesc $optRDesc $optQDesc $optXDesc )
optionsDescsNotes=($optADescNote $optBDescNote $optCDescNote $optDDescNote $optEDescNote $optFDescNote $optGDescNote 
$optHDescNote $optIDescNote $optJDescNote $optKDescNote $optLDescNote $optMDescNote $optNDescNote $optODescNote $optPDescNote $optRDescNote)

# declare -A creates associative array, allowing: declare -A a // a=([A]=0 [B]=1 [C]=2) // echo ${a[C]} will produce 2 
# allowing us to use non-sequential indexes for menu, allowing us to keep Q to quit (trivial but an exercise to enable)
# This allows us instant translation of the key'd in letter in the menu to the array of options via ${optionsIndexes[$choice]}.
#	 There may be a refactoring to isolate menu display from options selection and thus a direct case construct,
#	but at present, this works.
# The stroke of inspiration resolves to simplicity: optionsCount is # of valid menu options, and the menu display only shows those, BUT
#	we can tack on invisible options after that, thus enableing Q/X AND also extraneous helper functions as this expands, kind of a like a bonus!

declare -A -g optionsIndexes=()
optionsIndexes=( [A]=0 [B]=1 [C]=2 [D]=3 [E]=4 [F]=5 [G]=6 [H]=7 [I]=8 [J]=9 [K]=10 [L]=11 [M]=12 [N]=13 [O]=14 [P]=15 [R]=16 )
optionsIndexes+=( [Q]=17 [X]=18  )

# to allow reverse bridging of associative arrays, bash currently seems to need a mirrored array. Easy enough to do. This is required to 
#	produce the auto-inclusion of thhe letter'd key into the menu row, obviating the user manually editing the lines.
declare -A -g indexesToOptions=()
indexesToOptions=( [0]=A [1]=B [2]=C [3]=D [4]=E [5]=F [6]=G [7]=H [8]=I [9]=J [10]=K [11]=L [12]=M [13]=N [14]=O [15]=P [16]=R )
indexesToOptions+=( [17]=Q [18]=X  )

# there may be more efficient ways to create the accepted keys, but this is fun ;) v0.5 used a manual entry.
# declare -A acceptedKeys
acceptedKeys=( {A..P} {a..p} r R q Q x X )

# ====END====





